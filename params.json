{"name":"Pete","tagline":"Simple, yet powerful PL/SQL testing suite.","body":"<!-- START doctoc generated TOC please keep comment here to allow auto update -->\r\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\r\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\r\n\r\n- [Pete](#pete)\r\n    - [Convention over Configuration](#convention-over-configuration)\r\n    - [Configuration over Convention](#configuration-over-convention)\r\n- [Installation](#installation)\r\n- [Convention over Configuration](#convention-over-configuration-1)\r\n  - [Convention over Configuration tutorial](#convention-over-configuration-tutorial)\r\n    - [1. Create test package with description](#1-create-test-package-with-description)\r\n    - [2. Declare hooks - before and after each or all methods](#2-declare-hooks---before-and-after-each-or-all-methods)\r\n    - [3. Declare testing methods](#3-declare-testing-methods)\r\n    - [4. Implement hooks and testing methods](#4-implement-hooks-and-testing-methods)\r\n    - [5. Run test package](#5-run-test-package)\r\n      - [SQL*Plus](#sqlplus)\r\n- [Configuration over Convention](#configuration-over-convention-1)\r\n  - [Configuration over Convention tutorial](#configuration-over-convention-tutorial)\r\n    - [1. Create tested function](#1-create-tested-function)\r\n    - [2. Create testing procedure](#2-create-testing-procedure)\r\n    - [2. Configure test](#2-configure-test)\r\n      - [2.1 PL/SQL block definition](#21-plsql-block-definition)\r\n      - [2.2 Test case definition](#22-test-case-definition)\r\n      - [2.3 Input argument](#23-input-argument)\r\n      - [2.4 PL/SQL Block in Test Case](#24-plsql-block-in-test-case)\r\n    - [3. Execute Test Case](#3-execute-test-case)\r\n    - [4. Fix error in function](#4-fix-error-in-function)\r\n    - [5. Execute Test Case again](#5-execute-test-case-again)\r\n\r\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\r\n\r\n# Pete\r\n\r\nPete is simple, yet powerful PL/SQL testing suite. Pete allows you to choose the right approach for your PL/SQL  code testing needs\r\n\r\nWith Pete you can choose from 2 different approaches\r\n\r\n### Convention over Configuration\r\n\r\nwhen you want\r\n\r\n* quick learning curve\r\n* almost human language for describing tests\r\n* selfcontained tests\r\n     \r\n### Configuration over Convention\r\n\r\nwhen you want\r\n\r\n* run test on different data sets - reusable test cases/scripts\r\n* split responsibilities for creation of data and code\r\n\r\n# Installation\r\n\r\n**1. Grant required privileges to target schema**\r\n\r\n````\r\ngrant connect to <pete_schema>;  \r\ngrant create table to <pete_schema>;\r\ngrant create procedure to <pete_schema>;\r\ngrant create type to <pete_schema>;\r\ngrant create sequence to <pete_schema>;\r\ngrant create view to <pete_schema>;\r\n````\r\n\r\n**2. Connect to target schema and install Pete objects**\r\n\r\n````\r\nSQL> @install\r\n````\r\n\r\n# Convention over Configuration\r\n\r\nYou don't need to configure anything, just write your testing packages using simple convention and Pete will run your tests automagically.\r\n\r\n## Convention over Configuration tutorial\r\n\r\nFollow up this simple tutorial which will guide you through.\r\n\r\n1. Create test package specification and describe your test\r\n2. Declare hooks\r\n3. Declare testing methods\r\n3. Implement hooks and testing methods\r\n5. Run test package\r\n\r\n### 1. Create test package with description\r\n\r\n* package name has to have prefix `UT_`\r\n* package description has to be defined in `description` variable of package\r\n* variable have to be either `pete_core.typ_description` or some `varchar2` with less than `4000 bytes`\r\n\r\n````\r\nCREATE OR REPLACE PACKAGE ut_test AS\r\n\r\n    description VARCHAR2(255) := 'Test my amazing constraint';\r\n\r\nEND;\r\n/\r\n````\r\n\r\n### 2. Declare hooks - before and after each or all methods\r\n\r\n* `before_all` - executed once before all other methods\r\n* `before_each` - executed before each method - except hooks\r\n* `after_each` - execute after each method - except hooks\r\n* `after_all` - execute once after all other methods\r\n\r\nAll hook methods are optional. You choose whether to use them or not.\r\n\r\n````\r\nCREATE OR REPLACE PACKAGE ut_test AS\r\n\r\n    description VARCHAR2(255) := 'Test my amazing constraint';\r\n\r\n    -- hook method\r\n    PROCEDURE before_all;\r\n\r\n    -- hook method\r\n    PROCEDURE after_all;\r\n\r\nEND;\r\n/\r\n````\r\n\r\n### 3. Declare testing methods\r\n\r\n* a testing method has to be a procedure with zero mandatory arguments\r\n* there is no restriction on name of the method except hook method names - `before_all`, `before_each`, `after_each`, `after_all` which are reserved\r\n* methods are executed in order, in which they are defined in package specification\r\n    * just reorder methods in package specification to change execution order\r\n* it is best practice to describe what method does (or Pete makes up something generic like *\"Executing method ut_test.method_1\"*)\r\n    * it is even better to describe it using `default` value of some input argument (as you can use it in implementation, as you will see later)\r\n\r\n````\r\nCREATE OR REPLACE PACKAGE ut_test AS\r\n\r\n    description VARCHAR2(255) := 'Test my amazing constraint';\r\n\r\n    -- hook method\r\n    PROCEDURE before_all;\r\n\r\n    PROCEDURE ins_child_without_parent_fails(d VARCHAR2 := 'Insert child without existing parent fails');\r\n\r\n    PROCEDURE ins_child_with_parent_succeeds(d VARCHAR2 := 'Insert child with existing parent succeeds');\r\n\r\n    -- hook method\r\n    PROCEDURE after_all;\r\n\r\nEND;\r\n\r\n/\r\n````\r\n\r\n### 4. Implement hooks and testing methods\r\n\r\n* in package body implement `before_all` hook method\r\n\r\n````\r\nCREATE OR REPLACE PACKAGE BODY ut_test AS\r\n\r\n    PROCEDURE before_all IS\r\n    BEGIN\r\n        EXECUTE IMMEDIATE 'create table x_parent (id integer primary key)';\r\n        EXECUTE IMMEDIATE 'create table x_child (id integer primary key, parent_id integer references x_parent(id))';\r\n    END;\r\n\r\n````\r\n\r\n* implement first test method\r\n    * call `pete_logger.log_method_description(d)` to set method description\r\n    * implement test, that inserts into child table without existence of a referenced parent - it should fail\r\n    \r\n````\r\n    PROCEDURE ins_child_without_parent_fails(d VARCHAR2) IS\r\n        l_thrown BOOLEAN := FALSE;\r\n    BEGIN\r\n        --log\r\n        pete_logger.log_method_description(d);\r\n        --test\r\n        BEGIN\r\n            EXECUTE IMMEDIATE 'insert into x_child values (1,1)';\r\n            l_thrown := FALSE;\r\n        EXCEPTION\r\n            WHEN OTHERS THEN\r\n                l_thrown := TRUE;\r\n        END;\r\n        --assert\r\n        IF NOT l_thrown\r\n        THEN\r\n            raise_application_error(-20000,\r\n                                    q'{It should throw and it doesn't, so fix it!}'); --TODO: add description\r\n        END IF;\r\n    END ins_child_without_parent_fails;\r\n````\r\n\r\n* implement second test method\r\n    * again, set method description\r\n    * insert parent and then child record\r\n\r\n````\r\n    PROCEDURE ins_child_with_parent_succeeds(d VARCHAR2) IS\r\n    BEGIN\r\n        --log\r\n        pete_logger.log_method_description(d);\r\n        --assert\r\n        EXECUTE IMMEDIATE 'insert into x_parent values (1)';\r\n        EXECUTE IMMEDIATE 'insert into x_child values (1,1)';\r\n    END;\r\n````\r\n\r\n* implement `after_all` hook method to cleanup after tests\r\n\r\n````\r\n    PROCEDURE after_all IS\r\n    BEGIN\r\n        EXECUTE IMMEDIATE 'drop table x_child';\r\n        EXECUTE IMMEDIATE 'drop table x_parent';\r\n    END;\r\n\r\nEND;\r\n\r\n/\r\n````\r\n\r\n### 5. Run test package\r\nRunning tests in Pete is supereasy.\r\n\r\n#### SQL*Plus\r\n\r\n````\r\nSQL> set serveroutput on size unlimited\r\nSQL> set linesize 255\r\nSQL> set pages 0\r\nSQL> \r\nSQL> exec pete.run(a_package_name_in => 'UT_TEST');\r\n\r\n.Pete run @ 21-APR-15 02.42.52.753627000 PM +02:00 - SUCCESS\r\n.  Test my amazing constraint - SUCCESS\r\n.    BEFORE_ALL - SUCCESS\r\n.    Insert child without existing parent fails - SUCCESS\r\n.    Insert child with existing parent succeeds - SUCCESS\r\n.    AFTER_ALL - SUCCESS\r\n\r\nPL/SQL procedure successfully completed.\r\n\r\n````\r\n\r\n# Configuration over Convention\r\n\r\nUse Pete's Configuration over Convention mode when you want\r\n\r\n* run test on different data sets - reusable test cases/scripts\r\n* split responsibilities for creation of data and code\r\n\r\n# Configuration over Convention tutorial\r\n\r\n## Prereq\r\n\r\n[Install](Installation) Pete in Oracle's sample SCOTT schema.\r\n\r\n### 1. Create tested function\r\n\r\nCreate some function to test and make at least my favourite error and forget to return result from function\r\n  \r\n````\r\nCREATE OR REPLACE FUNCTION get_salary(a_deptno_in IN emp.sal%TYPE)\r\n    RETURN NUMBER AS\r\n    l_result NUMBER;\r\nBEGIN\r\n    SELECT SUM(sal) INTO l_result FROM emp WHERE deptno = a_deptno_in;\r\nEND;\r\n/\r\n````\r\n\r\n### 2. Create testing procedure\r\n\r\nAll testing procedured have to be able to be called using parameters `a_xml_in` - input XML and `a_xml_out` - output XML. All other parameters have to be optional.\r\nTesting procedure is just wrapper, that provides required interface to Pete.\r\n\r\n````\r\nCREATE OR REPLACE PROCEDURE test_get_salary\r\n(\r\n    a_xml_in  IN xmltype,\r\n    a_xml_out OUT xmltype\r\n) IS\r\n    l_result emp.sal%TYPE;\r\nBEGIN\r\n    --yuk!!!\r\n    l_result  := get_salary(a_deptno_in => to_number(a_xml_in.extract('/DEPTNO/text()')\r\n                                                     .getStringVal));\r\n    a_xml_out := xmltype.createxml('<TOTAL_SAL>' || l_result || '</TOTAL_SAL>');\r\nEND;\r\n\r\n/\r\n````\r\n\r\n### 2. Configure test\r\n\r\n#### 2.1 PL/SQL block definition\r\n\r\nCreate PL/SQL block definition in Pete repository.\r\n\r\n* id - get it from sequence\r\n* name - provide some nice name\r\n* description - describe test implemented by PLSQL block\r\n* method - in our case we have stored procedure, so only method argument will be specified\r\n\r\n````\r\nINSERT INTO pete_plsql_block\r\n    (id, name, description, method)\r\nVALUES\r\n    (petes_plsql_block.nextval,\r\n     'get_salary',\r\n     'generic get_salary test',\r\n     'TEST_GET_SALARY');\r\n````\r\n\r\n----\r\n\r\n**The rest of the columns**\r\n\r\n* test_script_id - identifier of TEST_SCRIPT entity. Use it when you want to \"bind\" PL/SQL block to specific test script only\r\n* owner, package, method - specify method to be executed\r\n* anonymous_block - specify anonymous PL/SQL block instead of stored procedure\r\n\r\n#### 2.2 Test case definition\r\n\r\nCreate test case definition in Pete repository.\r\n\r\n* id - get it from sequence\r\n* name - test case name - give it a good name\r\n* description - describe test case\r\n\r\n````\r\nINSERT INTO pete_test_case\r\n    (id, NAME, description)\r\nVALUES\r\n    (petes_test_case.nextval, 'get_salary', 'get_salary should work as expected');\r\n````\r\n\r\n----\r\n\r\n**The rest of the columns**\r\n\r\n* test_script_id - identifier of TEST_SCRIPT entity. Use it when you want to \"bind\" test case to specific test script only\r\n\r\n#### 2.3 Input argument\r\n\r\nCreate input argument\r\n\r\n* id - surrogate identifier, get it from sequence\r\n* name - name it well, it would help with reusing \r\n* value - value as XML\r\n\r\n````\r\nINSERT INTO pete_input_param\r\n    (id, name, value)\r\nVALUES\r\n    (petes_input_param.nextval, 'Accounting Department Identifier', '<DEPTNO>10</DEPTNO>');\r\n````\r\n\r\n----\r\n\r\n**The rest of the columns**\r\n\r\n* test_script_id - identifier of TEST_SCRIPT entity. Use it when you want to \"bind\" test case to specific test script only\r\n\r\n#### 2.4 PL/SQL Block in Test Case\r\n\r\nNow glue everything together - map PL/SQL to test case Test case mapping using input argument.\r\n\r\n* id - surrogate identifier, get it from sequence\r\n* test_case_id - identifier of our Test Case\r\n* pslql_block_id - identifier of our PL/SQL block\r\n* input_param_id - identifier of Input argument\r\n* description - describe instance of PL/SQL block\r\n* block_order - sort blocks in test case\r\n    \r\n````\r\nINSERT INTO pete_plsql_block_in_case\r\n    (id,\r\n     test_case_id,\r\n     plsql_block_id,\r\n     input_param_id,\r\n     block_order,\r\n     description)\r\nVALUES\r\n    (petes_plsql_block_in_case.nextval,\r\n     petes_test_case.currval,\r\n     petes_plsql_block.currval,\r\n     petes_input_param.currval,\r\n     1,\r\n     'should not fail');\r\n````\r\n\r\n**The rest of the columns**\r\n\r\n* output_param_id - identifier of expected result\r\n\r\n----\r\n\r\nand commit;\r\n\r\n````\r\ncommit;\r\n````\r\n\r\n### 3. Execute Test Case\r\n\r\nNow execute Test Case\r\n\r\n````\r\nbegin\r\n  pete.run(a_case_name_in => 'get_salary');\r\nend;\r\n/\r\n````\r\n\r\naaaaand ... it fails\r\n\r\n````\r\n.Pete run @ 23-APR-15 02.53.52.755920000 PM +02:00 - FAILURE\r\n.  get_salary should work as expected - FAILURE\r\n.    get_salary - FAILURE\r\n\r\nORA-06503: PL/SQL: Function returned without value\r\n --------------------------------------------------------------\r\nORA-06512: at \"SCOTT.GET_SALARY\", line 11\r\nORA-06512: at \"SCOTT.TEST_GET_SALARY\", line 9\r\nORA-06512: at line 2\r\nORA-06512: at \"SCOTT.PETE_CONFIGURATION_RUNNER\", line 86\r\n````\r\n\r\n### 4. Fix error in function\r\n\r\nAdd missing return from function.\r\n\r\n````\r\nCREATE OR REPLACE FUNCTION get_salary(a_deptno_in IN emp.sal%TYPE)\r\n    RETURN NUMBER AS\r\n    l_result NUMBER;\r\nBEGIN\r\n    SELECT SUM(sal) INTO l_result FROM emp WHERE deptno = a_deptno_in;\r\n    return l_result;\r\nEND;\r\n/\r\n````\r\n\r\n### 5. Execute Test Case again\r\n\r\nExecute Test Case again and now it succeeds!!!\r\n\r\n````\r\n\r\n.Pete run @ 23-APR-15 03.03.06.171390000 PM +02:00 - SUCCESS\r\n.  get_salary should work as expected - SUCCESS\r\n.    get_salary - SUCCESS\r\n\r\n\r\n````\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}