CREATE OR REPLACE PACKAGE ut_petet_plsql_block_in_case AS

    description pete_core.typ_description := 'PLSQL Block in Test Case Type';

    PROCEDURE ctor_with_block_id(d varchar2 := 'constructor with block as block id works');
    PROCEDURE ctor_with_block(d varchar2 := 'constructor with block as object works');
    PROCEDURE ctor_without_mandatory(d varchar2 := 'constructor without madatory attributes fails');
    PROCEDURE ctor_diff_obj_id_and_obj_id(d varchar2 := 'constructor with different <object>_id and <object>.id fails');

    PROCEDURE copy(d varchar2 := 'copy works');
    PROCEDURE equals(d varchar2 := 'equals works');

    PROCEDURE after_each;

END;
/
CREATE OR REPLACE PACKAGE BODY ut_petet_plsql_block_in_case AS

    -- NoFormat Start
    g_passthrough_anonymous_block varchar2(32767)
    := 'DECLARE' || CHR(10)
    || '    l_xml_in xmltype := :1;' || CHR(10)
    || 'BEGIN' || CHR(10)
    || '    :2 := l_xml_in;' || CHR(10)
    || 'END;';
    -- NoFormat End

    g_xml1 xmltype := xmltype.createxml('<foo>foo</foo>');
    g_xml2 xmltype := xmltype.createxml('<bar>bar</bar>');

    --------------------------------------------------------------------------------
    FUNCTION hlp_get_block(a_prefix_in IN varchar2) RETURN petet_plsql_block IS
    BEGIN
        RETURN petet_plsql_block(NAME            => a_prefix_in || 'block',
                                 anonymous_block => g_passthrough_anonymous_block);
    END;

    --------------------------------------------------------------------------------
    FUNCTION hlp_create_block(a_prefix_in IN varchar2) RETURN petet_plsql_block IS
        l_result petet_plsql_block := hlp_get_block(a_prefix_in => a_prefix_in);
    BEGIN
        pete_configuration_runner_adm.set_plsql_block(a_plsql_block_io => l_result);
        RETURN l_result;
    END;

    --------------------------------------------------------------------------------
    FUNCTION hlp_get_input_argument(a_prefix_in IN varchar2)
        RETURN petet_input_argument IS
    BEGIN
        RETURN petet_input_argument(NAME => a_prefix_in || 'input_argument');
    END;

    --------------------------------------------------------------------------------
    FUNCTION hlp_create_input_argument(a_prefix_in IN varchar2)
        RETURN petet_input_argument IS
        l_result petet_input_argument := hlp_get_input_argument(a_prefix_in => a_prefix_in);
    BEGIN
        pete_configuration_runner_adm.set_input_argument(a_input_argument_io => l_result);
        RETURN l_result;
    END;

    --------------------------------------------------------------------------------
    FUNCTION hlp_get_expected_result(a_prefix_in IN varchar2)
        RETURN petet_expected_result IS
    BEGIN
        RETURN petet_expected_result(NAME => a_prefix_in || 'expected_result');
    END;

    --------------------------------------------------------------------------------
    FUNCTION hlp_create_expected_result(a_prefix_in IN varchar2)
        RETURN petet_expected_result IS
        l_result petet_expected_result := hlp_get_expected_result(a_prefix_in => a_prefix_in);
    BEGIN
        pete_configuration_runner_adm.set_expected_result(a_expected_Result_io => l_result);
        RETURN l_result;
    END;

    --------------------------------------------------------------------------------
    FUNCTION hlp_get_plsql_block_in_case(a_prefix_in IN varchar2)
        RETURN petet_plsql_block_in_case IS
    BEGIN
        RETURN petet_plsql_block_in_case(id              => 1,
                                         test_case_id    => 1,
                                         plsql_block     => hlp_create_block(a_prefix_in => a_prefix_in),
                                         input_argument  => hlp_create_input_argument(a_prefix_in => a_prefix_in),
                                         expected_result => hlp_create_expected_result(a_prefix_in => a_prefix_in),
                                         position        => 1,
                                         stop_on_failure => pete_core.g_NO,
                                         run_modifier    => pete_core.g_SKIP,
                                         description     => 'd');
    END;

    --------------------------------------------------------------------------------
    PROCEDURE ctor_with_block_id(d varchar2) IS
        l_name                varchar2(255) := 'ctor_with_block_id';
        l_plsql_block         petet_plsql_block;
        l_plsql_block_in_case petet_plsql_block_in_case;
    BEGIN
        --log
        pete.set_method_description(d);
        --prepare
        l_plsql_block := hlp_create_block(a_prefix_in => l_name);
        --test
        l_plsql_block_in_case := petet_plsql_block_in_case(plsql_block_id => l_plsql_block.id);
        --assert
        pete_assert.eq(l_plsql_block.id, l_plsql_block_in_case.plsql_block_id);
    END;

    --------------------------------------------------------------------------------
    PROCEDURE ctor_with_block(d varchar2) IS
        l_name                varchar2(255) := 'ctor_with_block';
        l_plsql_block         petet_plsql_block;
        l_plsql_block_in_case petet_plsql_block_in_case;
    BEGIN
        --log
        pete.set_method_description(d);
        --prepare
        l_plsql_block := hlp_create_block(a_prefix_in => l_name);
        --test
        l_plsql_block_in_case := petet_plsql_block_in_case(plsql_block => l_plsql_block);
        --assert
        pete_assert.eq(pete_core.g_YES,
                       l_plsql_block.equals(l_plsql_block_in_case.plsql_block));
    END;

    --------------------------------------------------------------------------------
    PROCEDURE ctor_without_mandatory(d varchar2) IS
        l_thrown boolean := FALSE;
        --
        l_plsql_block_in_case petet_plsql_block_in_case;
    BEGIN
        --log
        pete.set_method_description(d);
        --prepare
        --test
        BEGIN
            l_plsql_block_in_case := petet_plsql_block_in_case();
            l_thrown              := FALSE;
        EXCEPTION
            WHEN OTHERS THEN
                l_thrown := TRUE;
        END;
        --assert
        IF NOT l_thrown
        THEN
            raise_application_error(-20000,
                                    'PETET_PLSQL_BLOCK_IN_CASE constructor should have thrown.');
        END IF;
    END;

    --------------------------------------------------------------------------------
    PROCEDURE ctor_diff_obj_id_and_obj_id(d varchar2) IS
        l_thrown boolean;
        --
        l_name varchar2(255) := 'ctor_diff_obj_id_and_obj_id';
        --
        l_plsql_block     petet_plsql_block;
        l_input_argument  petet_input_argument;
        l_expected_result petet_expected_result;
        --
        l_plsql_block_in_case petet_plsql_block_in_case;
    BEGIN
        --log
        pete.set_method_description(d);
        --prepare
        l_plsql_block     := hlp_create_block(a_prefix_in => l_name);
        l_input_argument  := hlp_create_input_argument(a_prefix_in => l_name);
        l_expected_result := hlp_create_expected_result(a_prefix_in => l_name);
        --test
        --plsql_block.id vs. plsql_block_id
        BEGIN
            l_plsql_block_in_case := petet_plsql_block_in_case(plsql_block_id => l_plsql_block.id + 1,
                                                               plsql_block    => l_plsql_block);
            l_thrown              := FALSE;
        EXCEPTION
            WHEN OTHERS THEN
                l_thrown := TRUE;
        END;
        --assert
        IF NOT l_thrown
        THEN
            raise_application_error(-20000,
                                    'PETET_PLSQL_BLOCK_IN_CASE should have thrown.');
        END IF;
        --input_argument.id vs. input_argument_id
        BEGIN
            l_plsql_block_in_case := petet_plsql_block_in_case(plsql_block_id    => l_plsql_block.id,
                                                               input_argument_id => l_input_argument.id + 1,
                                                               input_argument    => l_input_argument);
            l_thrown              := FALSE;
        EXCEPTION
            WHEN OTHERS THEN
                l_thrown := TRUE;
        END;
        --assert
        IF NOT l_thrown
        THEN
            raise_application_error(-20000,
                                    'PETET_PLSQL_BLOCK_IN_CASE should have thrown.');
        END IF;
        --expected_result.id vs. expected_result_id
        BEGIN
            l_plsql_block_in_case := petet_plsql_block_in_case(plsql_block_id     => l_plsql_block.id,
                                                               expected_result_id => l_expected_result.id + 1,
                                                               expected_result    => l_expected_result);
            l_thrown              := FALSE;
        EXCEPTION
            WHEN OTHERS THEN
                l_thrown := TRUE;
        END;
        --assert
        IF NOT l_thrown
        THEN
            raise_application_error(-20000,
                                    'PETET_PLSQL_BLOCK_IN_CASE should have thrown.');
        END IF;
    END;

    --------------------------------------------------------------------------------
    PROCEDURE copy(d varchar2) IS
        --
        l_name varchar2(255) := 'copy';
        --
        l_src petet_plsql_block_in_case;
        l_tgt petet_plsql_block_in_case;
        --
    BEGIN
        --log
        pete.set_method_description(d);
        --prepare
        l_src := hlp_get_plsql_block_in_case(a_prefix_in => l_name);
        --test
        l_tgt := l_src.copy;
        --assert
        pete_assert.eq(
            pete_core.g_YES,
            l_src.equals(l_tgt)
        );
    END;

    --------------------------------------------------------------------------------
    PROCEDURE equals(d varchar2) IS
        l_name varchar2(255) := 'equals';
        l_plsql_block_in_case_tmpl petet_plsql_block_in_case;
        l_plsql_block_in_case1 petet_plsql_block_in_case;
        l_plsql_block_in_case2 petet_plsql_block_in_case;
    BEGIN
        --log
        pete.set_method_description(d);
        --prepare template
        l_plsql_block_in_case_tmpl := hlp_get_plsql_block_in_case(l_name);
        --prepare case - deep
        l_plsql_block_in_case1 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case2 := l_plsql_block_in_case_tmpl.copy;
        --assert
        pete_assert.eq(a_expected_in => pete_core.g_YES,
                       a_actual_in   => l_plsql_block_in_case1.equals(a_obj_in => l_plsql_block_in_case2, a_deep_in => pete_core.g_YES));
        --prepare case - shallow
        l_plsql_block_in_case1 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case2 := l_plsql_block_in_case_tmpl.copy;
        --assert
        pete_assert.eq(a_expected_in => pete_core.g_YES,
                       a_actual_in   => l_plsql_block_in_case1.equals(a_obj_in => l_plsql_block_in_case2, a_deep_in => pete_core.g_NO));
        --prepare case - null = null
        l_plsql_block_in_case1 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case2 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case1.id := null;
        l_plsql_block_in_case2.id := null;
        --assert
        pete_assert.eq(a_expected_in => pete_core.g_YES,
                       a_actual_in   => l_plsql_block_in_case1.equals(l_plsql_block_in_case2));
        --prepare case null != not null
        l_plsql_block_in_case1 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case2 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case1.id := null;
        --assert
        pete_assert.eq(a_expected_in => pete_core.g_NO,
                       a_actual_in   => l_plsql_block_in_case1.equals(l_plsql_block_in_case2));
        --prepare case 1 != 2
        l_plsql_block_in_case1 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case2 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case1.id := 1;
        l_plsql_block_in_case2.id := 2;
        --assert
        pete_assert.eq(a_expected_in => pete_core.g_NO,
                       a_actual_in   => l_plsql_block_in_case1.equals(l_plsql_block_in_case2));
        --prepare case deepl inequality does not affect shallow equality
        l_plsql_block_in_case1 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case2 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case1.plsql_block.id := 1;
        l_plsql_block_in_case1.plsql_block.id := 2;
        --assert
        pete_assert.eq(a_expected_in => pete_core.g_YES,
                       a_actual_in   => l_plsql_block_in_case1.equals(l_plsql_block_in_case2));
        --prepare case deepl inequality affects deep equality
        l_plsql_block_in_case1 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case2 := l_plsql_block_in_case_tmpl.copy;
        l_plsql_block_in_case1.plsql_block.id := 1;
        l_plsql_block_in_case1.plsql_block.id := 2;
        --assert
        pete_assert.eq(a_expected_in => pete_core.g_NO,
                       a_actual_in   => l_plsql_block_in_case1.equals(a_obj_in => l_plsql_block_in_case2, a_deep_in => pete_core.g_YES));
    END;


    --------------------------------------------------------------------------------
    PROCEDURE after_each IS
    BEGIN
        ROLLBACK;
    END;

END;
/
